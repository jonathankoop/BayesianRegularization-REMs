---
title: "Running Application"
format: html
editor: visual
---

```{r}
library(pacman)
p_load("tidyverse", "igraph", "httr", "jsonlite", "rvest", "stringr", "stringdist", "remify", "remstats", "remstimate", "shrinkem", "brms")

load("../../Functions/functions.RData")
load("../../CleanedData/Data_Popular_100.RData")
load("../../CleanedData/covar_spotify.RData")
```

# Preparing Data

```{r}
data_popular <- data_popular %>% 
  mutate(release_date = as.Date(release_date)) %>%
  arrange(release_date) %>% 
  dplyr::select(release_date, Artist_1, Artist_2)

reh <- remify(data_popular, directed = T, model = "tie")

effects <- ~ 1 + indegreeSender(scaling = "std") + reciprocity(scaling = "std") +
  outdegreeReceiver(scaling = "std") + indegreeReceiver(scaling = "std") +
  outdegreeSender(scaling = "std") + totaldegreeSender(scaling = "std") +
  totaldegreeReceiver(scaling = "std") + otp(scaling = "std") +
  itp(scaling = "std") + isp(scaling = "std") + psABBA() +
  psABBY() + psABXA() + psABXB() + psABXY() + psABAY() + psABAB() +
  rrankSend() + rrankReceive() + recencyContinue() + recencySendSender() +
  recencyReceiveReceiver() + recencySendReceiver() + recencyReceiveSender() +
  osp(scaling = "std") + inertia(scaling = "std") +
  same("gender") +
  minimum("popularity") +
  maximum("popularity")

covar <- covar %>% 
  rename(name = Artist_Names)

statistics <- remstats(reh = reh, tie_effects = effects, attr_actors = covar)
```

# MLE

```{r}
fit <- remstimate::remstimate(
        reh = reh,
        stats = statistics,
        method = "MLE",
        timing = "interval"
      )

selected_mle <- as.data.frame(summary(fit)$coefsTab) %>%
  filter(`Pr(>|z|)` < 0.05)
```

# ABR

```{r}
# Extract coefficients and set up for shrinkage
coefs <- summary(fit)$coefsTab
estimates <- coef(fit)
cov <- fit$vcov
cov[upper.tri(cov)] <- t(cov)[upper.tri(cov)]

set.seed(123)

shrink_hs <- shrinkem(estimates, cov, type = "horseshoe")
shrink_ridge <- shrinkem(estimates, cov, type = "ridge")

selected_abr_hs <- summary(shrink_hs) %>% 
  filter(nonzero == 1)
  
selected_abr_ridge <- summary(shrink_ridge) %>% 
  filter(nonzero == 1)
```

```{r}
# Create data frame with draws
draws_abr_hs <- shrink_hs$draws$beta %>% 
  as.data.frame() %>%
  mutate(Iteration = 1:nrow(.))

# Reshape the data into long format for ggplot2.
draws_abr_hs_long <- melt(df, id.vars = "Iteration", 
                variable.name = "Parameter", 
                value.name = "Value")

parameter_names <- levels(draws_abr_hs_long$Parameter)

trace_plots_abr_hs <- list()

for (i in seq_along(parameter_names)) {
  # Subset the data for the current parameter
  df_param <- draws_abr_hs_long %>% filter(Parameter == parameter_names[i])
  
  # Create Histogram (left panel)
  hist_plot <- ggplot(df_param, aes(x = Value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black", alpha = 0.7) +
    labs(x = paste("b_", parameter_names[i]),
         y = "Count") +
    theme_minimal()
  
  # Create Trace Plot (right panel)
  trace_plot <- ggplot(df_param, aes(x = Iteration, y = Value)) +
    geom_line(color = "darkblue", alpha = 0.8) +
    labs(x = "Iteration",
         y = paste("b_", parameter_names[i])) +
    theme_minimal()
  
  # Combine the histogram and trace plot side by side
  trace_plots_abr_hs[[i]] <- hist_plot + trace_plot + plot_layout(ncol = 2)
}

trace_plots_abr_hs
```

# EBR

```{r}
poisson_df <- function(events, tie_stats, tie_reh, t0 = 0) {
  
  # Get unique actors in the event data
  actors <- sort(unique(c(events$actor1, events$actor2)))
  
  # Creating risk set
  risk_set <- vector("list", dim(tie_stats)[2])
for (i in 1:dim(tie_stats)[2]) {
  risk_set[[i]] <- getDyad(tie_reh, i)
}

risk_set <- do.call(rbind, risk_set)[,2:3]

  M <- tie_reh$M # number of events
  poisson_list <- vector("list", M) # initialize list to store data frames
  
  for (m in 1:M) {
    
    # Get statistics for current event m
    stats_m <- as.data.frame(tie_stats[m, , ])
    
    # Combine risk set with covariates
    df_m <- cbind(risk_set, stats_m)
    
    # Create binary outcome y
    df_m$y <- ifelse(df_m[,1] == events$actor1[m] & df_m[,2] == events$actor2[m], 1, 0)
    
    # Add offset
    df_m$logDelta <- log(tie_reh$intereventTime[m])
    
    # Store data frame for event m
    poisson_list[[m]] <- df_m
  }
  
  # Combine all event data frames in list into one data frame
  df_poisson <- do.call(rbind, poisson_list)
  df_poisson <- df_poisson %>% 
    dplyr::select(-1, -2, -baseline) %>% 
    # turn all variables that include "same_" to factors
    mutate(across(contains("same_"), as.factor)) %>%
    # turn y to integer
    mutate(y = as.integer(y))
  
  return(df_poisson)
}
```

```{r}
df_poisson <- poisson_df(reh$edgelist, tie_stats = statistics, tie_reh = reh)
      
      
      # Create Formula
      predictors <- names(df_poisson)[1:(which(colnames(df_poisson) == "y") - 1)]
      glm_formula <- as.formula(paste("y ~", paste(
        c(predictors, "offset(logDelta)"), collapse = " + "
      )))

      # Estimate the model using brm
      model <- brm(formula = glm_formula, data = df_poisson, family = poisson(link = "log"), 
               prior = set_prior(horseshoe(df = 3, scale_global = 1,
                                     df_global = 3, scale_slab = 2,
                                     df_slab = 4, par_ratio = NULL,
                                     autoscale = TRUE), class = "b"),
               backend = "cmdstanr",
               cores = 4)
      
      
save(model, file = "Data/ebr_hs.RData")
```

## Evaluating Traces

```{r}
coefs <- summary(model)$fixed
for (i in rownames(coefs)) {
  plot(model, variable = paste0("b_", i))
}
```

